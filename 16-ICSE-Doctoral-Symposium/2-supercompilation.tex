
\section{Supercompilation}

\label{sec:supercompilation}


This chapter describes supercompilation, what it is, related work, and what are the main uses so far.

\section{Related Work}


\section{What is supercompilation?}

Supercompilation was introduced by V. F Turchin~\cite{Turchin:1986:CS:5956.5957}

introduced by V. F Turchin~\cite{Turchin:1986:CS:5956.5957}
for the language Refal

We have built a supercompiler using its operational semantics, Sefsoft style
~\cite{Sestoft:1997:DLA:969886.969887}

~\cite{sorm94} give the first formulation for supercompilation for a more well-known functional language setting.
It is a first-order functional language.


The main idea behind the program analysis by supercompilation is that supercompilation
“normalizes” and “trivializes” the structure of programs by
removing modularity and levels of abstraction (carefully elaborated by the
programmer).
Thus, although the transformed program becomes less humanfriendly,
it may be more convenient for automatic analysis.



Supercompilation on call-by-name, Mitchell~\cite{Mitchell:2010:RS:1863543.1863588}

supercompilation by evaluation
~\cite{Bolingbroke:2010:SE:1863523.1863540}

~\cite{UCAM-CL-TR-835}


%\url{https://themonadreader.files.wordpress.com/2014/04/super-final.pdf}

supercompilation is based on driving, folding, generalization
