
\section{Contributions}

\label{sec:contributions}

\subsection{Visualization Tool to Understand Supercompilation}

\subsection{Accelerating Parser Combinators by Supercompilation}

\subsection{Deducing Rewrite Rules by Supercompilation}

Rewrite rules are an extension to GHC that allows the programmer 
Rewrite rules were introduced in GHC~\cite{citeulike:7953458} to provide oportunites to opmimize programs.

Several libraries 
Stream fusion

Stream fusion \cite{Coutts:2007:SFL:1291151.1291199}

What kinds of rewrite rules are currently present in Hackage?


For instance, 
Until what extent can Supercompilation deduce the rewrite rules that are currently present in Hackage?

\subsection{Supercompiling Dependent-Type Checking}


In programming languages, a type system is a way to restrict/prevent certain programs from running.
A type system helps the programmer to avoid certain kind of errors.
In Traditional type systems as in Hindley-Milner, there is a clear distinction between values belonging to a specific type, and that type.

With the advent of dependent type, this distinction is less clear.
In a dependent-type system, a type expression can not only depend on other base types, but also can \textbf{depend} on value expression, hence the name.

\textbf{Dependent type checking}



\section{Dependent Type checking}

normalisation during type-checking



Dependent-Type-Supercompilation
Supercompiled-based Language with Dependent Types




In this chapter we plan to outline what are the step to carry-on in the rest of the Ph.D. program

What are the shortcomings of dep-type checking.





Programming Languages offer a wide variety of abstractions to aid the programmer in solving a specific problem.
Programmers use abstraction by to create solve bigger problems
using a languages.

introduced by V. F Turchin~\cite{Turchin:1986:CS:5956.5957}
for the language Refal

~\cite{sorm94} give the first formulation for supercompilation for a more well-known functional language setting.
It is a first-order functional language.


Supercompilation is a program transformation technique aimed at reducing unnecessary computations.
It does so by removing abstractions elaborated by the programmer, giving as output a \emph{``normalized''} program.
Supercompilation can be used for multiple purposes, mainly for program optimization, but also for theorem proving, and logic programming.

But to date, there is no mainstream Supercompiler being used, either in academic or commercial projects.
The main reason being that Supercompilation has some short-comings, for the studied domains.

In this proposal, we study how actually Supercompilation is well-suited for these wide-range applications.
We will explore different domains where we believe that Supercompilation might have better results than the current state-of-art.
Our mail goal is to make Supercompilation practical, by finding the a \emph{``killer application''} for it, or by showing what are the short-comings.


%The main idea behind the program analysis by supercompilation is that supercompilation
%“normalizes” and “trivializes” the structure of programs by removing modularity and levels of abstraction 
%when composing functional programs
%(carefully elaborated by the programmer).
%Thus, although the transformed program becomes less humanfriendly, it may be more convenient for automatic analysis.
%Although Supercompilation being a single transformation technique, it can be used for multiple purposes.
%Program optimization it is the most well-known use for Supercompilation.
%, but also for theorem proving, and logic programming.



In recent year dependent type programming has become more and more popular.
This can be seen as the adoption in particular by the Haskell programming language.
with GADTs, DAtaKind?
Typechecking for dependent types languages, or also contracts, has a series drawback, it can be undecidable depending on the expressive power of the base language.
In its core, dependent-typechecking, involves the manipulation of open terms or expressions, i.e., an expression containing free variables.

Supercompilation is a program transformation technique develop by V. Turchin develop in Rusia in the 60's. It is aimed at extracting the essence of programs.
The original development of Supercompilation was in terms of the Refal language.
In the past decades, supercompilation was adapted to more well-known setting, i.e., functional languages, in particular lambda calculus.
In its core, supercompilation is a technique to symbolically evaluate programs, i.e., to evaluate an expression with free variables.

Therefore, given that both dependent-type checking and supercompilation involve dealing with open expression, it is natural to ask:

What is the connection between dependent-type checking and supercompilation?

Can Supercompilation be used to implement dependent types more effectively/efficiently?

That is, our plan is analyze the spectrum of possible outcomes to this question.
Are they equivalent?
If not, what is the relationship between them? Can you reduce one to the other?
Which one is more powerful?
Can you change the dependent-type language to be adapted to supercompilation, in a way that can be more expressive than Hindley-Milner typechecking/inference?

To this end, we will present Dependent-Type languages with particular focus in type checking dependent languages in \S~\ref{ch:dependent-types}.
Supercompilation is introduced in \S~\ref{ch:supercompilation}.



* Is supercompilation a good choice to type check dependent type languages?
* Are they equivalent? (with some notion of equivalence)
* If not, is it possible to reduce one to the other?

To this end, the steps would be:

* Study what are the limitations of the current state of dependent type checking, or dependent type languages, e.g., having total functions.
* How is dep-type checking actually implemented? (Theorem Prover?)
* Study the limits of supercompilation. What supercompilation can or can't achieve.
* Investigate if there is a design space where supercompilation can fit, without losing type expressiveness.




In programming languages, a type system is a way to restrict/prevent certain programs from running.
A type system helps the programmer to avoid certain kind of errors.
In Traditional type systems as in Hindley-Milner, there is a clear distinction between values belonging to a specific type, and that type.

With the advent of dependent type, this distinction is less clear.
In a dependent-type system, a type expression can not only depend on other base types, but also can \textbf{depend} on value expression, hence the name.

\textbf{Dependent type checking}



normalisation during type-checking


Dependent-Type-Supercompilation
Supercompiled-based Language with Dependent Types


In this chapter we plan to outline what are the step to carry-on in the rest of the Ph.D. program

What are the shortcomings of dep-type checking.